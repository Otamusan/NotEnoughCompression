buildscript {
	repositories {
		mavenCentral()
		jcenter()
		maven {
			name = 'forge'
			url = 'http://files.minecraftforge.net/maven'
		}
		maven {
			name = 'sonatype'
			url = 'https://oss.sonatype.org/content/repositories/snapshots/'
		}
		maven {
			url 'https://plugins.gradle.org/m2/'
		}
	}
	dependencies {
		classpath project.forgegradle
	}
}

plugins {
	id 'com.palantir.git-version' version '0.7.1'
	id 'co.riiid.gradle' version '0.4.2'
	id 'com.jfrog.bintray' version '1.7.3'
	id 'com.matthewprenger.cursegradle' version '1.0.9'
	id 'com.github.johnrengelman.shadow' version '2.0.1'
}

apply plugin: project.forgegradle_plugin
apply plugin: 'maven-publish'

project.metaClass.isProperty = { propName ->
	return delegate.hasProperty(propName)&&!delegate.property(propName).isEmpty()
}

[shadowJar, jar]*.classifier = project.hasProperty('extra_classifier') ? project.extra_classifier : 'universal'

import org.apache.commons.lang.StringUtils

ext {
	mod_commonname = "${rootProject.name}-common"
	mod_build_prefix = 'b'

	assert project.isProperty('version_major'): 'missing property: version_major'
	assert project.isProperty('version_minor'): 'missing property: version_minor'
	assert project.isProperty('version_patch'): 'missing property: version_patch'

	mod_travis = System.getenv('TRAVIS') as boolean
	mod_buildnumber = System.getenv('TRAVIS_BUILD_NUMBER') as Integer
	mod_buildtag = System.getenv('TRAVIS_TAG')
	mod_prerelease = mod_autorelease = mod_travis && StringUtils.isEmpty(mod_buildtag)

	if (mod_buildtag!=null && mod_buildtag.startsWith(mod_build_prefix))
		throw new GradleException("Oops, circulated travis build. A push starting with the prefix '${mod_build_prefix}' was detected: ${mod_buildtag}")

	(mod_version_build, mod_version_meta) = ({
		if (mod_buildnumber)
			return [".${mod_buildnumber}", '']
		else
			return ({
				def buildnumberfile = file 'artifacts/.buildnumber/buildnum.properties'

				def version_build = ({
					def buildnumbermicro = 1
					def props = new Properties()
					if (buildnumberfile.exists())
						buildnumberfile.withInputStream { stream ->
							props.load stream
						}

					if (props.buildnumber &&
							props.version_major == project.version_major &&
							props.version_minor == project.version_minor &&
							props.version_patch == project.version_patch)
						buildnumbermicro = props.buildnumber as Integer
					return buildnumbermicro
				})()

				def buildtextmicro = String.format('%03d', version_build)
				def buildtext = "+${buildtextmicro}"

				task increment {
					doLast {
						def props = new Properties()
						props.version_major = project.version_major
						props.version_minor = project.version_minor
						props.version_patch = project.version_patch
						props.buildnumber = version_build+1 as String
						buildnumberfile.parentFile.mkdirs()
						buildnumberfile.withOutputStream { stream ->
							props.store stream, 'Build Number Property'
						}
					}
				}

				afterEvaluate {
					tasks.build.dependsOn increment
				}

				['', buildtext]
			})()
	})()

	mod_version_min = "${project.version_major}.${project.version_minor}.${project.version_patch}"
	mod_version = "${mod_version_min}${mod_version_build}"
	mod_version_full = "${mod_version}${mod_version_meta}"
	mod_artifacts_dir = file "artifacts/${mod_version_min}/${mod_version_full}"
	mod_artifacts_release_dir = file 'artifacts/release'

	mod_git_repo = null
	mod_git_head = null
	try {
		mod_git_repo = plugins.findPlugin('com.palantir.git-version').gitRepo(rootProject).repository
		mod_git_head = mod_git_repo.getRef('HEAD').objectId.name()
	} catch(IllegalArgumentException e) {
	}

	// Parse Changelog
	def parseChangelog = { changelog ->
		def title = null
		def msg = null
		def releasetype = 'release'

		if (changelog!=null) {
			// Beta mode and Alpha mode
			if (StringUtils.contains(changelog, '[beta]')) {
				changelog = StringUtils.replace(changelog, '[beta]', '')
				releasetype = 'beta'
			} else if (StringUtils.contains(changelog, '[alpha]')) {
				changelog = StringUtils.replace(changelog, '[alpha]', '')
				releasetype = 'alpha'
			}

			// Split Title and Body
			def tagtitle = StringUtils.substringBefore(changelog, '\n')
			def tagmsg = StringUtils.stripStart(StringUtils.substringAfter(changelog, '\n'), '\n')
			if (!StringUtils.isEmpty(tagtitle))
				title = tagtitle
			if (!StringUtils.isEmpty(tagmsg))
				msg = tagmsg
		}
		return [title, msg, releasetype]
	}

	// Changelog Text
	(mod_changelog_title, mod_changelog, mod_releasetype) = ({
		// Get Changelog from Git Tag or File
		def (changelog_title, changelog, releasetype) = parseChangelog(({
			if (!StringUtils.isEmpty(mod_buildtag)&&mod_git_repo!=null) {
				def git_ref = mod_git_repo.getRef "refs/tags/${mod_buildtag}"

				if (git_ref!=null) {
					def git_revwalk = new org.eclipse.jgit.revwalk.RevWalk(mod_git_repo)
					try {
						return git_revwalk.parseTag(git_ref.getObjectId()).getFullMessage()
					} catch(org.eclipse.jgit.errors.IncorrectObjectTypeException e) {
					} finally {
						git_revwalk.dispose()
					}
				}
			} else {
				def fileChangelog = project.isProperty('extra_changelog_location') ? file(project.extra_changelog_location) : file('changelog.md')
				if (fileChangelog.exists())
					return fileChangelog.getText('UTF-8')
			}
			return null
		})())

		// Replace Version Text
		def convertChangelog = { str ->
			def str1 = str
				.replace('{version}', mod_version)
				.replace('{version_full}', mod_version_full)
			if (mod_buildnumber!=null)
				return str1
					.replace('{version_number}', "${mod_buildnumber}")
			return str1
		}

		// Generate Default Changelog
		def (n_changelog_title, n_changelog) = ({
			if (mod_buildnumber!=null)
				return ["v${mod_version}", "v${mod_version_min} Build${mod_buildnumber}"]
			else
				return ["v${mod_version_full}", "v${mod_version_full}"]
		})()

		if (changelog_title!=null)
			n_changelog_title = convertChangelog(changelog_title)
		if (changelog!=null)
			n_changelog = convertChangelog(changelog)
		return [n_changelog_title, n_changelog, releasetype]
	})()

	sec_curseforge_key = System.getenv('CURSEFORGE_TOKEN') ?: project.isProperty('api_key_curseforge') ? project.api_key_curseforge : null
	sec_github_key = System.getenv('GITHUB_TOKEN') ?: project.isProperty('api_key_github') ? project.api_key_github : null
	sec_bintray_user = System.getenv('BINTRAY_USER') ?: project.isProperty('api_user_bintray') ? project.api_user_bintray : null
	sec_bintray_key = System.getenv('BINTRAY_KEY') ?: project.isProperty('api_key_bintray') ? project.api_key_github : null
	sec_keystore_location = System.getenv('KEYSTORE_LOCATION') ?: project.isProperty('keystore_location') ? project.keystore_location : null
	sec_keystore_alias = System.getenv('KEYSTORE_ALIAS') ?: project.isProperty('keystore_alias') ? project.keystore_alias : null
	sec_keystore_password = System.getenv('KEYSTORE_PASSWORD') ?: project.isProperty('keystore_password') ? project.keystore_password : null
}

configurations {
	shade
	compile.extendsFrom shade
}

version = "${project.version_minecraft}-${mod_version}"

[compileJava, compileApiJava, compileTestJava]*.options*.encoding = 'UTF-8'
sourceCompatibility = targetCompatibility ='1.8'

if (tasks.findByPath('makeEclipseCleanRunClient')!=null) {
	tasks.makeEclipseCleanRunClient.doFirst {
		setArguments '--username otamusan'
		if (project.isProperty('extra_fmlcore'))
			setJvmArguments "-Dfml.coreMods.load=${project.extra_fmlcore}"
	}
}

minecraft {
	version = "${project.version_minecraft}-${project.version_forge}"

	if (project.isProperty('version_mappings'))
		mappings = project.version_mappings

	if (!project.isProperty('run_location'))
		runDir = 'run'
	else
		runDir = run_location.replace('{modid}', project.modid).replace('{mcversion}', project.version_minecraft)

	replaceIn 'Reference.java'
	replace '${modid}', project.modid
	replace '${modname}', project.modname
	replace '${version}', mod_version
	replace '${mcversion}', project.version_minecraft
	replace '${forgeversion}', project.version_forge
}

sourceSets {
}

processResources {
	// this will ensure that this task is redone when the versions change.
	inputs.property 'version', mod_version
	inputs.property 'mcversion', project.minecraft.version

	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'

		expand([
				'modid'				: project.modid,
				'modname'			: project.modname,
				'version'			: mod_version,
				'mcversion'			: project.version_minecraft,
				'forgeversion'		: project.version_forge,
				'minforgeversion'	: project.isProperty('version_minforge') ? project.version_minforge : project.version_forge,
		])
	}

	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}
}

repositories {
	jcenter()
	maven {
		name = 'CurseForge'
		url = 'https://minecraft.curseforge.com/api/maven/'
	}
}

idea {
	module {
		downloadSources = true
		inheritOutputDirs = true
	}
}

dependencies {
	shade fileTree(dir: 'libs/shade', include: '*.jar')
	deobfProvided "mezz.jei:jei_1.12.2:${version_jei}:api"
  	runtime "mezz.jei:jei_1.12.2:${version_jei}"
}

ext.commonManifest = {}

if (file('project.gradle').exists())
	apply from: 'project.gradle'

commonManifest = commonManifest << {
	if (project.isProperty('extra_fmlcore'))
		attributes 'FMLCorePlugin': project.extra_fmlcore
	if (project.isProperty('extra_fmlmod'))
		attributes 'FMLCorePluginContainsFMLMod': project.extra_fmlcore
	if (project.isProperty('extra_fmlat'))
		attributes 'FMLAT': project.extra_fmlat
	// Prevent from CurseForge duplicate error
	attributes 'ModVersion': mod_version_full
}

reobf {
	shadowJar{ mappingType = 'SEARGE' }
	jar{ mappingType = 'SEARGE' }
}

shadowJar {
	from sourceSets.main.output
	from sourceSets.api.output
	manifest commonManifest
	configurations = [project.configurations.shade]
}

jar {
	from sourceSets.main.output
	from sourceSets.api.output
	classifier = 'diff'
	manifest commonManifest
}

sourceJar {
	from sourceSets.api.allSource
}

task devJar(dependsOn: 'classes', type: Jar) {
	from sourceSets.main.output
	from sourceSets.api.output
	classifier = 'dev'
	manifest commonManifest
}

task apiJar(dependsOn: 'classes', type: Jar) {
	from sourceSets.api.output
	classifier = 'api'
	manifest commonManifest
}

artifacts {
	archives shadowJar
	//archives jar
	archives devJar
	archives sourceJar
	//archives apiJar
}

[jar, shadowJar, devJar, sourceJar, apiJar]*.destinationDir = mod_artifacts_dir

task releaseArtifacts(dependsOn: 'build', type: Sync) {
	from mod_artifacts_dir
	into mod_artifacts_release_dir
}

gradle.taskGraph.whenReady {taskGraph ->
	if (taskGraph.hasTask(tasks.githubRelease)) {
		assert sec_github_key!=null, 'missing sec_github_key'
		assert project.isProperty('extra_github_owner'), 'missing extra_github_owner'
		assert project.isProperty('extra_github_repo'), 'missing extra_github_repo'
	}
}
if (sec_github_key!=null&&project.isProperty('extra_github_owner')&&project.isProperty('extra_github_repo')&&mod_git_head!=null) {
	github {
		tasks.githubRelease.dependsOn 'build'
		prerelease = mod_prerelease
		owner = project.extra_github_owner
		repo = project.extra_github_repo
		token = sec_github_key
		tagName = mod_travis ? (mod_autorelease ? "${mod_build_prefix}${mod_buildnumber}" : mod_buildtag) : mod_version_full
		targetCommitish = mod_git_head
		name = mod_changelog_title
		body = mod_changelog
		draft = false
		def allassets = [tasks.shadowJar/*, tasks.jar*/, tasks.devJar, tasks.sourceJar/*, tasks.apiJar*/]
		assets = allassets*.outputs*.files*.asPath*.tr('\\','/')
	}
}

publishing {
	publications {
		ModPublication(MavenPublication) {
			groupId = project.group
			artifactId = project.modid
			version = "${mod_version}"
			artifact jar
			subprojects.each { p ->
				artifact p.shadowJar
				//artifact p.jar
				artifact p.devJar
				artifact p.sourceJar
				//artifact p.apiJar
			}
		}
	}
}

gradle.taskGraph.whenReady {taskGraph ->
	if (taskGraph.hasTask(tasks.bintrayUpload)) {
		assert sec_bintray_user!=null, 'missing sec_bintray_user'
		assert sec_bintray_key!=null, 'missing sec_bintray_key'
		assert project.isProperty('extra_bintray_repo'), 'missing extra_bintray_repo'
		assert project.isProperty('extra_bintray_name'), 'missing extra_bintray_name'
	}
}
if (sec_bintray_user!=null&&sec_bintray_key!=null&&project.isProperty('extra_bintray_repo')&&project.isProperty('extra_bintray_name')) {
	bintray {
		tasks.bintrayUpload.enabled = !mod_autorelease
		user = sec_bintray_user
		key = sec_bintray_key
		publications = ['ModPublication']
		publish = true
		pkg {
			userOrg = project.extra_bintray_org
			repo = project.extra_bintray_repo
			name = project.extra_bintray_name
			version {
				name = "${mod_version}"
				released = new Date()
				desc = "${mod_changelog_title}"+(StringUtils.isEmpty(mod_changelog)?'':"\n\n${mod_changelog}")
				vcsTag = mod_buildtag
			}
		}
	}
} else
	tasks.bintrayUpload.enabled = false

gradle.taskGraph.whenReady {taskGraph ->
	if (taskGraph.hasTask(tasks.curseforge)) {
		assert sec_curseforge_key!=null, 'missing sec_curseforge_key'
		assert project.isProperty('extra_curseforge_id'), 'missing extra_curseforge_id'
	}
}
if (sec_curseforge_key!=null&&project.isProperty('extra_curseforge_id')) {
	curseforge {
		tasks.curseforge.enabled = !mod_autorelease && project.name!=mod_commonname

		apiKey = sec_curseforge_key
		project {
			id = project.extra_curseforge_id

			changelogType = 'markdown'
			changelog = mod_changelog

			releaseType = mod_releasetype

			mainArtifact(shadowJar) {
				displayName = "${shadowJar.baseName}-${shadowJar.version}"
			}
			[/*jar, */devJar, sourceJar/*, apiJar*/].each { jar ->
				addArtifact(jar) {
					displayName = "${jar.baseName}-${jar.version}-${jar.classifier}"
				}
			}

			relations {
				optionalLibrary 'notenoughitems'
			}
		}
	}
} else
	tasks.curseforge.enabled = false

['project.gradle'].each { f -> [rootProject, project].each { p -> def fs = p.file(f); if (fs.exists()) apply from: fs } }

